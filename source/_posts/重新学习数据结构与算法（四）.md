---
title: 重新学习数据结构与算法（四）
date: 2022-09-13 16:00:29
category: [数据结构]
tags: [c/c++, 数据结构, 算法]
---
## 特殊线性表

前面我们讲解的基础的线性表，通过使用线性表，我们就可以很方便地对数据进行管理了。这一部分，我们将继续认识一些特殊的线性表，它有着特别的规则，在特定场景有着很大的作用，也是考察的重点。

### 栈


栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样：

![](/img/article/data_structure/zhanduilie/zhan1.png)


也就是说，我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，我们一般将其竖着看：


![](/img/article/data_structure/zhanduilie/zhan2.png)



底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out）


实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们先使用顺序表来实现一下，这里我们需要实现两个新的操作：

- pop：出栈操作，从栈顶取出一个元素。
- push：入栈操作，向栈中压入一个新的元素。


首先还是按照我们的顺序表进行编写：

```c
typedef int E;

struct Stack {
    E * array;
    int capacity;
    int top;   //这里使用top来表示当前的栈顶位置，存的是栈顶元素的下标
};

typedef struct Stack * ArrayStack;  //起个别名
```

接着我们需要编写一个初始化方法：


```c
_Bool initStack(ArrayStack stack){
    stack->array = malloc(sizeof(E) * 10);
    if(stack->array == NULL) return 0;
    stack->capacity = 10;   //容量还是10
    stack->top = -1;   //由于栈内没有元素，那么栈顶默认就为-1
    return 1;
}
```

```c
int main(){
    struct Stack stack;
    initStack(&stack);
}
```

接着就是栈的两个操作了，一个是入栈操作，一个是出栈操作：

```c
_Bool pushStack(ArrayStack stack, E element){
    //入栈操作只需要给元素就可以，不需要index，因为只能从尾部入栈
}
```

由于入栈只能在尾部插入，所以就很好写了：


```c
_Bool pushStack(ArrayStack stack, E element){
    stack->array[stack->top + 1] = element;   //直接设定栈顶元素
    stack->top++;   //栈顶top变量记得自增
    return 1;
}
```

我们来测试一下吧：


```c
void printStack(ArrayStack stack){
    printf("| ");
    for (int i = 0; i < stack->top + 1; ++i) {
        printf("%d, ", stack->array[i]);
    }
    printf("\n");
}

int main(){
    struct Stack stack;
    initStack(&stack);
    for (int i = 0; i < 3; ++i) {
        pushStack(&stack, i*100);
    }
    printStack(&stack);
}
```


测试结果也是正确的：

![](/img/article/data_structure/zhanduilie/zhan3.png)


可以看到，从栈底到栈顶一次是0、100、200，不过我们现在的push操作还不够完美，因为栈有可能塞满，所以要进行扩容处理：


```c
_Bool pushStack(ArrayStack stack, E element){
    if(stack->top + 1 == stack->capacity) {  //栈顶+1如果等于容量的话，那么说明已经塞满了
        int newCapacity = stack->capacity + (stack->capacity >> 1);   //大体操作和顺序表一致
        E * newArray = realloc(stack->array, newCapacity * sizeof(E));
        if(newArray == NULL) return 0;
        stack->array = newArray;
        stack->capacity = newCapacity;
    }
    stack->array[stack->top + 1] = element;
    stack->top++;
    return 1;
}
```


这样我们的入栈操作就编写完成了，接着是出栈操作，出栈操作我们只需要将栈顶元素取出即可：


```c
_Bool isEmpty(ArrayStack stack){   //在出栈之前，我们还需要使用isEmpty判断一下栈是否为空，空栈元素都没有出个毛
    return stack->top == -1;   
}

E popStack(ArrayStack stack){
    return stack->array[stack->top--];   //直接返回栈顶元素，注意多加一个自减操作
}
```

我们来测试一下吧：


```c
int main(){
    struct Stack stack;
    initStack(&stack);
    for (int i = 0; i < 3; ++i) {
        pushStack(&stack, i*100);
    }
    printStack(&stack);
    while (!isEmpty(&stack)) {
        printf("%d ", popStack(&stack));   //将栈中所有元素依次出栈
    }
}
```

可以看到，出栈顺序和入栈顺序是完全相反的：

![](/img/article/data_structure/zhanduilie/zhan4.png)


当然使用数组实现栈除了这种可以自己扩容的之外，也有固定大小的栈，当栈已满时，就无法再进行入栈操作了。


不过有些时候，栈的利用率可能会很低，这个时候我们可以将一个固定长度的数组共享给两个栈来使用：


![](/img/article/data_structure/zhanduilie/zhan5.png)


数组的两头分别作为两个栈的栈底，当两个栈的栈顶指针相遇时（栈顶指针下标之差绝对值为1时），表示栈已满。通过这种方式，我们就可以将数组占用的空间更充分地使用，这样的栈我们称为**共享栈**。


前面我们演示了使用顺序表实现栈，我们接着来看如何使用链表来实现栈，实际上使用链表会更加的方便，我们可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点：


![](/img/article/data_structure/zhanduilie/zhan6.png)


当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下：

```c

typedef int E;

struct ListNode {
    E element;
    struct ListNode * next;
};

typedef struct ListNode * Node;

void initStack(Node head){
    head->next = NULL;
}

int main(){
    struct ListNode head;
    initStack(&head);
}
```

接着我们来编写一下入栈操作：


![](/img/article/data_structure/zhanduilie/zhan7.png)


代码如下：


```c
_Bool pushStack(Node head, E element){
    Node node = malloc(sizeof(struct ListNode));   //创建新的结点
    if(node == NULL) return 0;   //失败就返回0
    node->next = head->next;   //将当前结点的下一个设定为头结点的下一个
    node->element = element;   //设置元素
    head->next = node;   //将头结点的下一个设定为当前结点
    return 1;
}
```

我们来编写一个测试：


```c
void printStack(Node head){
    printf("| ");
    head = head->next;
    while (head){
        printf("%d ", head->element);
        head = head->next;
    }
    printf("\n");
}

int main(){
    struct ListNode head;
    initStack(&head);
    for (int i = 0; i < 3; ++i) {
        pushStack(&head, i*100);
    }
    printStack(&head);
}
```

可以看到结果没有问题：

![](/img/article/data_structure/zhanduilie/zhan8.png)


其实出栈也是同理，所以我们只需要将第一个元素移除即可：


```c
_Bool isEmpty(Node head){
    return head->next == NULL;   //判断栈是否为空只需要看头结点下一个是否为NULL即可
}

E popStack(Node head){
    Node top = head->next;
    head->next = head->next->next;
    E e = top->element;
    free(top);  //别忘了释放结点的内存
    return e;   //返回出栈元素
}
```

这里我们来测试一下：


```c
int main(){
    struct ListNode head;
    initStack(&head);
    for (int i = 0; i < 3; ++i) {
        pushStack(&head, i*100);
    }
    printStack(&head);
    while (!isEmpty(&head)) {
        printf("%d ", popStack(&head));   //将栈中所有元素依次出栈
    }
}
```

![](/img/article/data_structure/zhanduilie/zhan9.png)


实际上无论使用链表还是顺序表，都可以很轻松地实现栈，因为栈的插入和删除操作很特殊。


**栈练习题：**


1.  若进栈序列为1，2，3，4，则不可能得到的出栈序列是？

    A.  3，2，1，4       B.  3，2，4，1

    C.  4，2，3，1       D.  2，3，4，1

注意进栈并不一定会一次性全部进栈，可能会出现边进边出的情况，所以出栈的顺序可能有很多种情况，首先来看A，第一个出栈的是3，那么按照顺序，说明前面一定入栈了2、1，在出栈时4还没有入栈，然后是2、1最后是4，没有问题。接着是B，跟前面的A一样，不过这次是先出站3、2，而1留在栈中，接着4入栈，然后再让4、1出栈，也是正确的。然后是C，首先是4出栈，那么说明前三个一定都入栈了，而此时却紧接着的一定是3，而这里是2，错误。所以选择C 

2.  假设有5个整数以1、2、3、4、5的顺序被压入堆栈，且出栈顺序为3、5、4、2、1，那么栈大小至少为？

    A.2

    B.3

    C.4
    
    D.5

首先我们分析一下，第一个出栈的元素为3，那么也就是说前面的1、2都在栈内，所以大小至少为3，然后是5，那么说明此时栈内为1、2、4，算是出栈的5，那么至少需要的大小就是4了，所以选择C 


### 队列

前面我们学习了栈，栈中元素只能栈顶出入，它是一种特殊的线性表，同样的，队列（Queue）也是一种特殊的线性表。

就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾：

![](/img/article/data_structure/zhanduilie/zhan10.png)


秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。


想要实现队列也是很简单的，也可以通过两种线性表来实现，我们先来看看使用顺序表如何实现队列，假设一开始的时候队列中有0个元素，队首和队尾一般都初始都是-1这个位置：

![](/img/article/data_structure/zhanduilie/zhan11.png)



此时有新的元素入队了，队尾向后移动一格（+1），然后在所指向位置插入新的元素：


![](/img/article/data_structure/zhanduilie/zhan12.png)


之后都是同样的方式进行插入，队尾会一直向后移动：


![](/img/article/data_structure/zhanduilie/zhan13.png)


现在我们想要执行出队操作了，那么需要将队首向后移动一格，然后删除队首指向的元素：


![](/img/article/data_structure/zhanduilie/zhan14.png)



看起来设计的还挺不错的，不过这样有一个问题，这个队列是一次性的，如果队列经过反复出队入队操作，那么最后指针会直接指向数组的最后，如果我们延长数组的话，也不是一个办法，不可能无限制的延伸下去吧？所以一般我们采用循环队列的形式，来实现重复使用一个数组（不过就没办法扩容了，大小是固定的）